<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æé€Ÿå…‰è½® - é™€èºä»ªèµ›è½¦</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: auto;
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            color: white;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }

        /* é€Ÿåº¦ä»ªè¡¨ç›˜ */
        .hud-center {
            text-align: center;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-family: 'Courier New', monospace;
        }

        .speed-val {
            font-size: 3rem;
            font-weight: bold;
        }

        .speed-label {
            font-size: 0.8rem;
            letter-spacing: 2px;
        }

        /* å¼€å§‹/æƒé™é®ç½© */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #fff;
            font-style: italic;
            text-transform: uppercase;
            background: linear-gradient(90deg, #ff00cc, #3333ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .start-btn {
            background: linear-gradient(45deg, #ff00cc, #3333ff);
            border: none;
            padding: 15px 50px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 30px;
            margin-top: 20px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(51, 51, 255, 0.5);
            animation: pulse 1.5s infinite;
        }

        .tip {
            color: #aaa;
            margin-top: 15px;
            font-size: 0.9rem;
            max-width: 80%;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(51, 51, 255, 0.5);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 40px rgba(51, 51, 255, 0.8);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(51, 51, 255, 0.5);
            }
        }

        /* ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶ (å…œåº•) */
        .touch-controls {
            display: flex;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: auto;
            z-index: 5;
        }

        .touch-left,
        .touch-right {
            flex: 1;
        }
    </style>

    <!-- Three.js æ ¸å¿ƒ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- åå¤„ç†ç‰¹æ•ˆåº“ (å®ç°å…‰æ™• Bloom) -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

</head>

<body>

    <div id="start-screen">
        <h1>æé€Ÿå…‰è½®</h1>
        <p style="color:white">Motorcycle Racing</p>
        <button class="start-btn" onclick="startGame()">å¯åŠ¨å¼•æ“</button>
        <p class="tip">ğŸ“± æ‰‹æœºç©å®¶ï¼šå·¦å³å€¾æ–œæ‰‹æœºæ¥è½¬å¼¯ (éœ€è¦æˆæƒ)<br>ğŸ’» ç”µè„‘ç©å®¶ï¼šä½¿ç”¨å·¦å³æ–¹å‘é”®</p>
    </div>

    <div id="ui-layer">
        <div class="header">
            <button class="back-btn" onclick="history.back()">ğŸ </button>
        </div>
        <div class="hud-center" style="margin-top: 50px;">
            <div class="speed-val" id="score">0</div>
            <div class="speed-label">KM/H</div>
        </div>
        <div style="flex:1"></div>
    </div>

    <!-- å·¦å³è§¦æ‘¸åŒºåŸŸ (å¤‡ç”¨æ–¹æ¡ˆ) -->
    <div class="touch-controls">
        <div class="touch-left" id="btn-left"></div>
        <div class="touch-right" id="btn-right"></div>
    </div>

    <div id="game-container"></div>

    <script>
        // ================= é…ç½®å‚æ•° =================
        const CONFIG = {
            speed: 0.8,         // åŸºç¡€é€Ÿåº¦
            roadWidth: 20,      // èµ›é“å®½åº¦
            color: 0x00ffff,    // éœ“è™¹è“
            color2: 0xff00cc    // éœ“è™¹ç²‰
        };

        // ================= æ ¸å¿ƒå˜é‡ =================
        let scene, camera, renderer, composer;
        let bike, roadGrid, particles;
        let obstacles = [];
        let gameActive = false;
        let score = 0;
        let frameId;

        // æ“æ§å˜é‡
        let bikeX = 0;
        let targetTilt = 0;
        let currentTilt = 0;

        // éŸ³æ•ˆå¼•æ“
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let engineOsc;

        function init() {
            const container = document.getElementById('game-container');

            // 1. åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.03); // é»‘è‰²è¿·é›¾ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ

            // 2. ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 3, 6);
            camera.lookAt(0, 0, -10);

            // 3. æ¸²æŸ“å™¨ (å¼€å¯é˜´å½±å’ŒæŠ—é”¯é½¿)
            renderer = new THREE.WebGLRenderer({ antialias: false }); // åå¤„ç†å¼€å¯æ—¶å»ºè®®å…³é—­è‡ªå¸¦æŠ—é”¯é½¿ä»¥æå‡æ€§èƒ½
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ï¼Œé˜²å¡é¡¿
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // 4. ç¯å…‰ (æ¨¡æ‹ŸçœŸå®å…‰ç…§)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            // æ‘©æ‰˜è½¦å¤´ç¯ (å®æ—¶å…‰æº)
            const spotLight = new THREE.SpotLight(0xffffff, 20);
            spotLight.position.set(0, 5, 0);
            spotLight.angle = 0.6;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            scene.add(spotLight);

            // 5. åå¤„ç† (Bloom è¾‰å…‰ - æ¨¡æ‹Ÿå…‰è¿½æ•ˆæœçš„æ ¸å¿ƒ)
            const renderScene = new THREE.RenderPass(scene, camera);

            // UnrealBloomPass å‚æ•°: åˆ†è¾¨ç‡, å¼ºåº¦, åŠå¾„, é˜ˆå€¼
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 6. åˆ›å»ºç‰©ä½“
            createRoad();
            createBike();
            createEnvironment();

            // 7. ç›‘å¬
            window.addEventListener('resize', onWindowResize, false);
            setupControls();
        }

        // --- ç‰©ä½“æ„å»º ---

        function createRoad() {
            // ä½¿ç”¨ç½‘æ ¼è¾…åŠ©çº¿æ¨¡æ‹Ÿèµ›åšæœ‹å…‹è·¯é¢
            const gridHelper = new THREE.GridHelper(200, 200, CONFIG.color2, 0x222222);
            gridHelper.position.y = -1;
            gridHelper.position.z = -50;
            gridHelper.scale.z = 5; // æ‹‰é•¿äº§ç”Ÿé€Ÿåº¦æ„Ÿ
            scene.add(gridHelper);
            roadGrid = gridHelper;
        }

        function createBike() {
            bike = new THREE.Group();

            // è½¦èº« (å‘å…‰æè´¨)
            const bodyGeo = new THREE.BoxGeometry(0.8, 0.5, 2);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.2,
                metalness: 0.8
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);

            // éœ“è™¹ç¯æ¡
            const neonGeo = new THREE.BoxGeometry(0.82, 0.1, 2.05);
            const neonMat = new THREE.MeshBasicMaterial({ color: CONFIG.color }); // Basicæè´¨ä¸å—å…‰ç…§å½±å“ï¼Œè‡ªå¸¦å‘å…‰æ„Ÿ
            const neon = new THREE.Mesh(neonGeo, neonMat);
            neon.position.y = 0.2;

            // åè½® (å‘å…‰ç¯)
            const wheelGeo = new THREE.TorusGeometry(0.4, 0.1, 16, 32);
            const wheelMat = new THREE.MeshBasicMaterial({ color: CONFIG.color2 });
            const wheelBack = new THREE.Mesh(wheelGeo, wheelMat);
            wheelBack.position.set(0, -0.2, 0.8);

            // å°¾ç„°ç²’å­
            const trailGeo = new THREE.BufferGeometry();
            const trailMat = new THREE.PointsMaterial({ color: CONFIG.color, size: 0.1 });
            // ...ç®€åŒ–å¤„ç†ï¼Œç”¨ç¯å…‰ä»£æ›¿å°¾ç„°

            // æ‘©æ‰˜è½¦å¤§ç¯
            const headlight = new THREE.PointLight(CONFIG.color, 2, 20);
            headlight.position.set(0, 0.5, -1.5);
            bike.add(headlight);

            bike.add(body);
            bike.add(neon);
            bike.add(wheelBack);

            bike.position.y = -0.5;
            bike.position.z = 2;
            scene.add(bike);
        }

        function createEnvironment() {
            // æ˜Ÿç©ºç²’å­
            const starsGeo = new THREE.BufferGeometry();
            const starsCount = 1000;
            const posArray = new Float32Array(starsCount * 3);

            for (let i = 0; i < starsCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }
            starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starsMat = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff });
            const starMesh = new THREE.Points(starsGeo, starsMat);
            scene.add(starMesh);
            particles = starMesh;

            // è¿œå¤„çš„èµ›åšå»ºç­‘ (ç®€å•çš„å‘å…‰æŸ±å­)
            for (let i = 0; i < 20; i++) {
                const h = Math.random() * 10 + 5;
                const geo = new THREE.BoxGeometry(2, h, 2);
                const mat = new THREE.MeshBasicMaterial({ color: 0x0a0a2a });
                // è¾¹ç¼˜å‘å…‰
                const edges = new THREE.EdgesGeometry(geo);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x3333ff }));

                const building = new THREE.Group();
                building.add(new THREE.Mesh(geo, mat));
                building.add(line);

                building.position.set((Math.random() - 0.5) * 80, h / 2 - 10, -Math.random() * 100 - 20);
                if (Math.abs(building.position.x) < 15) building.position.x += 20; // é¿å¼€èµ›é“

                scene.add(building);
            }
        }

        function createObstacle() {
            // éšæœºç”Ÿæˆéšœç¢ç‰©
            const type = Math.random() > 0.5 ? 'box' : 'cone';
            let mesh;

            if (type === 'box') {
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
                mesh = new THREE.Mesh(geo, mat);
            } else {
                const geo = new THREE.ConeGeometry(0.5, 1.5, 16);
                const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x552200 });
                mesh = new THREE.Mesh(geo, mat);
            }

            // éšæœºèµ›é“ä½ç½® (-8 åˆ° 8)
            mesh.position.set((Math.random() - 0.5) * 16, -0.5, -60);
            scene.add(mesh);
            obstacles.push(mesh);
        }

        // --- æ¸¸æˆé€»è¾‘ ---

        function update() {
            if (!gameActive) return;

            // 1. æ‘©æ‰˜è½¦æ§åˆ¶å¹³æ»‘ç§»åŠ¨
            // ä½¿ç”¨ Lerp æ’å€¼è®©ç§»åŠ¨çœ‹èµ·æ¥æœ‰ç‰©ç†æƒ¯æ€§
            bike.position.x += (bikeX - bike.position.x) * 0.1;

            // å€¾æ–œè½¦èº«æ•ˆæœ (æ ¹æ®ç§»åŠ¨æ–¹å‘)
            targetTilt = (bikeX - bike.position.x) * -2; // å‘å·¦ç§»è½¦èº«å‘å·¦å€¾
            bike.rotation.z += (targetTilt - bike.rotation.z) * 0.1;

            // 2. åœºæ™¯ç§»åŠ¨æ¨¡æ‹Ÿ (æ— é™è·¯é¢)
            roadGrid.position.z += CONFIG.speed;
            if (roadGrid.position.z > 0) roadGrid.position.z = -50;

            // 3. ç²’å­é£é€
            particles.position.z += CONFIG.speed / 2;
            if (particles.position.z > 20) particles.position.z = 0;

            // 4. éšœç¢ç‰©ç®¡ç†
            if (Math.random() < 0.02) createObstacle(); // ç”Ÿæˆæ¦‚ç‡

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.position.z += CONFIG.speed;

                // ç¢°æ’æ£€æµ‹ (ç®€å•çš„è·ç¦»æ£€æµ‹)
                const dist = obs.position.distanceTo(bike.position);
                if (dist < 1.2) {
                    gameOver();
                }

                // æ¸…ç†
                if (obs.position.z > 10) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                    score += 10;
                    document.getElementById('score').innerText = score;
                    // é€Ÿåº¦éšåˆ†æ•°å¢åŠ 
                    if (score % 100 === 0) CONFIG.speed += 0.1;
                }
            }

            // å¼•æ“å£°æµªæ¨¡æ‹Ÿ
            updateEngineSound();

            composer.render();
            frameId = requestAnimationFrame(update);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- æ§åˆ¶è¾“å…¥ ---

        function setupControls() {
            // 1. é”®ç›˜ (PC)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') bikeX = Math.max(bikeX - 3, -8);
                if (e.key === 'ArrowRight') bikeX = Math.min(bikeX + 3, 8);
            });

            // 2. è§¦æ‘¸æŒ‰é’® (æ‰‹æœºå…œåº•)
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            let moveInterval;

            const startMove = (dir) => {
                if (moveInterval) clearInterval(moveInterval);
                moveInterval = setInterval(() => {
                    bikeX += dir * 0.5;
                    bikeX = Math.max(Math.min(bikeX, 8), -8);
                }, 20);
            };
            const stopMove = () => clearInterval(moveInterval);

            btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); startMove(-1); });
            btnLeft.addEventListener('touchend', stopMove);
            btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); startMove(1); });
            btnRight.addEventListener('touchend', stopMove);

            // 3. é™€èºä»ª (æ ¸å¿ƒ)
            window.addEventListener('deviceorientation', handleOrientation);
        }

        function handleOrientation(event) {
            if (!gameActive) return;
            // Gamma æ˜¯å·¦å³å€¾æ–œ (-90 åˆ° 90)
            const tilt = event.gamma;

            if (tilt) {
                // æ˜ å°„å€¾æ–œè§’åº¦åˆ°èµ›é“ä½ç½®
                // é™åˆ¶åœ¨ -30åº¦ åˆ° 30åº¦ ä¹‹é—´æ¯”è¾ƒå¥½æ“æ§
                let targetX = (tilt / 30) * 8;
                targetX = Math.max(Math.min(targetX, 8), -8);
                bikeX = targetX;
            }
        }

        // --- æ¸¸æˆæµç¨‹ ---

        async function startGame() {
            // iOS 13+ æƒé™è¯·æ±‚
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        // æˆæƒæˆåŠŸ
                    } else {
                        alert("ä¸ºäº†ä½“éªŒä½“æ„Ÿæ§åˆ¶ï¼Œè¯·å…è®¸è®¿é—®åŠ¨ä½œä¸æ–¹å‘æƒé™ã€‚");
                    }
                } catch (e) {
                    console.error(e);
                }
            }

            document.getElementById('start-screen').style.display = 'none';
            gameActive = true;
            score = 0;
            CONFIG.speed = 0.8;
            bikeX = 0;

            initAudio(); // å¯åŠ¨å¼•æ“å£°
            update();
        }

        function gameOver() {
            gameActive = false;
            cancelAnimationFrame(frameId);
            stopAudio();

            // ç®€å•çš„æ’å‡»ç‰¹æ•ˆ
            bike.rotation.x = -Math.PI / 4;
            bike.position.y = 0.5;
            renderer.render(scene, camera); // æ¸²æŸ“æœ€åä¸€å¸§

            setTimeout(() => {
                alert(`æ¯”èµ›ç»“æŸï¼ä½ çš„æ—¶é€Ÿè¾¾åˆ°äº† ${score} KM/H`);
                location.reload();
            }, 500);
        }

        // --- ç®€æ˜“å¼•æ“å£°åˆæˆ (Web Audio API) ---
        function initAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            engineOsc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            engineOsc.type = 'sawtooth'; // é”¯é½¿æ³¢ç±»ä¼¼å¼•æ“å£°
            engineOsc.frequency.value = 100;
            gainNode.gain.value = 0.1;

            engineOsc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            engineOsc.start();
        }

        function updateEngineSound() {
            if (engineOsc) {
                // é¢‘ç‡éšé€Ÿåº¦å¢åŠ ï¼Œæ¨¡æ‹Ÿå‡æ¡£
                engineOsc.frequency.value = 100 + (score * 2) + (Math.random() * 20);
            }
        }

        function stopAudio() {
            if (engineOsc) {
                engineOsc.stop();
                engineOsc = null;
            }
        }

        // å¯åŠ¨åˆå§‹åŒ–
        init();

    </script>
</body>

</html>